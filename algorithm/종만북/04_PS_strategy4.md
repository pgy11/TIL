# 4. 알고리즘 정당성 증명

### 1. 귀납법

- 개별적인 특수한 사실들이나 현상에서 일반적인 결론을 도출하는 추론 방식

- 반복적인 구조를 갖는 명제들을 증명하는데 유용하게 사용된다.

- 귀납법 증명은 **단계 나누기**, **첫 단계 증명**, **귀납 증명**순으로 이루어진다.

  - 단계 나누기: 증명하고 싶은 사실을 여러단계로 나눈다.
  - 첫 단계 증명: 첫 단계에서, 증명하고 싶은 내용이 성립함을 확인한다.
  - 귀납 증명: 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보이는지 확인한다.

  <br>

- Example1

  ```markdown
  ### 도미노
  100개의 도미노가 순서대로 놓여있다고 생각해보자. 그리고 다음 2가지 사실이 존재한다.
  
  
  1. 첫 번째 도미노는 직접 손으로 밀어서 쓰러트린다.
  2. 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.
  
  - 단계 나누기: 100개의 도미노를 도미노 하나씩 나눈다.
  	-i.e. 귀납법으로 증명하기위해, 한 번에 도미노 100개를 사용하는 것이 아닌, 각 단계마다 도미노 1개만 사용한다.
  
  - 첫 단계 증명: 첫 번째 도미노가 넘어짐을 확인한다.
  
  - 귀납 증명: 이전 단계에서 도미노가 넘어졌다면, 다음 도미노가 반드시 넘어짐을 확인한다.
  ```

<br>

- Exmaple2

  ```markdown
  ### 사다리 게임
  맨 위 선택지와 맨 아래 선택지가 1:1 대응하는 것이 사다리 게임의 특징이다.
  이를 증명해보자.
  
  우리에게 주어진 것은 N개의 세로줄만 있는 사다리이다.
  
  - 단계 나누기: 가로 줄 하나를 긋기가 한 단계이다.
  
  - 첫 단계 증명: N개의 세로줄만 있는 사다리가 1:1대응을 이룬다는 것을 확인한다.
  
  - 귀납 증명: 가로줄을 하나 그었을 때, 사다리가 1:1대응을 이룬다는 것을 확인한다.
  ```

  <br>

### 2. 반복문 불변식

- 알고리즘의 반복문이 실행 될 때, 사실이나 식이 계속 성립해야한다. 

  - 불변식을 만들고 반복문에서 식이 변하면 안된다.

  <br>

- 귀납법을 이용하여 알고리즘의 정당성을 증명할 때, 사용

- 반복문 불변식이 깨질 때, 단정문을 이용하여, 강제 종료하는 방법이 있다. 

  - 단정문은 속도에 영향을 주기 때문에, 많이 실행되는 반복문에 단정문을 쓰는 것은 비추천

  <br>

- 불변식을 이용한 반복문의 정당성을 아래와 같이 증명 할 수 있다.

  ```markdown
  1. 반복문 진입시에 불변식이 성립함을 보인다.
  2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다.
  3. 반복문 종료 할 때도, 불변식이 성립하면, 항상 우리가 정답을 구했음을 보인다.
  ```

  <br>

- Example

  ```python
  # 이진 탐색 (우리가 생각하는 이진 탐색이 아님 종만북 참고.)
  
  # 필수 조건: arr은 오름차순으로 정렬된 배열
  # 결과: arr[i-1] < x <= arr[i]인 i를 반환한다.
  # 이 때 arr[-1] = 음의 무한대, arr[n]을 양의 무한대라고 가정한다.
  def binsearch(arr, x):
      n = len(arr)
      lo, hi = -1, n
      
      # 반복문 불변식1: lo < hi
      # 반복문 불변식2: arr[lo] < x <= arr[hi]
      # 불변식은 여기서 부터 성립해야한다.
      while lo + 1 < hi:
          mid = (lo + hi) // 2
          if arr[mid] < x: lo = mid
          else: hi = mid
          # 불변식은 여기서도 성립해야한다.
          # end
          
      return hi
  # end
  ```

  ```markdown
  ### 이진 탐색 반복문 불변식 증명
  
  - 반복문에서 불변식이 성립한다고 가정, `return`문에 도달 했을 때
  	- `while`문의 조건: `lo + 1 >= hi`일 때, `while`문이 실행되지 않는다. 
  	불변식1에 의해 `lo < hi`이므로, `while`문은 `lo == hi`일 떄 종료한다.
  
  	- `arr[lo] < x <= arr[hi]`: 불변식이 성립하다고 가정했기 때문에, 이 사실은 자명하다.
  	
  - 반복문에서의 불변식
  	- 초기 조건: `while`문이 처음 시작 할 때, `lo = -1, hi = n`으로 초기화. 
  	여기서 `hi == 0`이면, `while`문이 실행되지 않기 때문에, 불변식1 성립한다.
  	한편, `arr[-1] < arr[n]`이므로 불변식2도 성립한다.
  	
      - 유지 조건:
      	- 불변식1: `while`문 내부로 들어왔다는 것은 `lo`와 `hi`의 차이가 2이상 난다는 것을 의미한다. 
      	따라서 `mid`는 항상 두 값의 사이에 위치한다. 
      	위의 사실로부터, 조건에 따라 `lo = mid` or `hi = mid`가 되어도, 불변식1은 항상 성립한다.
      	
      	- 불변식2: 
      		- `arr[mid] < x`일 때: `x <= arr[hi]`라는 사실은 변하지 않는다. 
      		따라서 `arr[mid] < x <= arr[hi]`가 성립한다. 
      		위의 사실로부터, `lo = mid`가 되어도, 불변식2는 성립한다.
      		
      		- `x <= arr[mid]`일 때: `arr[lo] < x`라는 사실은 변하지 않는다.
              따라서 `arr[lo] < x <= arr[mid]`가 성립한다.
              위의 사실로부터, `hi = mid`가 되어도, 불변식2는 성립한다.
  ```

  <br>

### 3. 귀류법

- 반증법

- 증명하려는 명제의 결론이 부정이라는 것을 가정하였을 때, 그 가정이 모순됨을 보여, 원래의 명제가 참인 것을 증명하는 방법

  - `p`이면 `q`이다라는 명제가 있다. 
  - 위의 명제에서 `q`를 부정하여, `p`이면 `q`가 아니다라는 명제를 만들고, 이 명제가 **모순**임을 증명하여, **기존의 명제**가 **참**임을 보여준다.

  <br>

- 내가 선택한 알고리즘이 최선의 선택이라는 것을 보여주기 위해 사용

  - i.e. 다른 방법들을 보여주고 그 방법이 최선이 아님을 보여주면 된다.

  <br>

### 4. 비둘기 집 원리

- 10마리의 비둘기가 9개의 비둘기 집에 들어갔다면, 비둘기 2마리 이상이 들어간 비둘기 집이 반드시 존재한다.

- 중복된 값이나 연산이 존재한다.

- Exmaple

  ```python
  # 순환 소수 찾기
  # 아래의 함수를 순환 소수도 고려하는 함수로 만들어야한다.
  # i.e. 순환 소수를 고려하지 않으면, 종료가 안된다.
  
  # 분수를 소수형태로 출력하는 함수
  def print_digit(a, b):
      i = 0
      while a > 0:
          if i == 1: print('.', end = '')
          i += 1
          print(str(a//b))
          a = (a % b) * 10
  ```

  ```markdown
  ### 순환 소수 찾기
  
  - 순환 소수이면, 같은 수가 어느 시점에서 나타나게 된다.
  - 어느 시점을 구하는 방법은 아래와 같다.
  
  1. a % b가 가질 수 있는 값은 [0, b-1]이다.
  2. `while`문이 `b+1`번 반복 되었다면, 비둘기 집 원리에 따라, 같은 값이 반드시 존재한다.
  3. 2번째로 같은 값이 나온 시점 전까지가 무한히 순환 된다는 것을 의미한다.
  4. 따라서 해당 시점에서 `while`문을 종료한다.
  	
  ```

  <br>

### 5. 구성적 증명

- 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해 사용된다
- 답을 만드는 알고리즘을 제시함으로써, 답이 존재함을 보이는 것
- 구성적 증명의 내용은 사실상 알고리즘이다.













